"use strict";(self.webpackChunkdelta_docs_1=self.webpackChunkdelta_docs_1||[]).push([[754],{7219:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"background/glossary","title":"Glossary of delta terms","description":"delta terms and definitions","source":"@site/docs/background/glossary.md","sourceDirName":"background","slug":"/background/glossary","permalink":"/docs/docs/background/glossary","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Glossary of delta terms","description":"delta terms and definitions","sidebar_label":"Glossary","sidebar_position":1},"sidebar":"docSidebar","previous":{"title":"delta Protocol Background","permalink":"/docs/docs/background/"},"next":{"title":"Tokens","permalink":"/docs/docs/background/tokens"}}');var o=n(4848),s=n(8453);const i={title:"Glossary of delta terms",description:"delta terms and definitions",sidebar_label:"Glossary",sidebar_position:1},l="Glossary of delta terms",d={},r=[{value:"Base Layer",id:"base-layer",level:3},{value:"Execution Layer",id:"execution-layer",level:3},{value:"Validator",id:"validator",level:3},{value:"Domain",id:"domain",level:3},{value:"Executor",id:"executor",level:3},{value:"Shard",id:"shard",level:3},{value:"Transaction",id:"transaction",level:3},{value:"State Diff",id:"state-diff",level:3},{value:"State Diff List (SDL)",id:"state-diff-list-sdl",level:3},{value:"SDL Proof",id:"sdl-proof",level:3},{value:"Laws",id:"laws",level:3},{value:"Global Laws",id:"global-laws",level:3},{value:"Local Laws",id:"local-laws",level:3},{value:"Planck",id:"planck",level:3},{value:"Executor Lease Agreement (ELA)",id:"ela",level:3},{value:"Vault",id:"vault",level:3},{value:"Token Mint",id:"token-mint",level:3},{value:"Token Holding",id:"token-holding",level:3},{value:"Debit (debit allowances)",id:"debit-debit-allowances",level:3}];function c(e){const a={h1:"h1",h3:"h3",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.header,{children:(0,o.jsx)(a.h1,{id:"glossary-of-delta-terms",children:"Glossary of delta terms"})}),"\n",(0,o.jsx)(a.h3,{id:"base-layer",children:"Base Layer"}),"\n",(0,o.jsx)(a.p,{children:"The network of validators that use consensus to validate proofs and SDLs sent from domains, and track global state."}),"\n",(0,o.jsx)(a.h3,{id:"execution-layer",children:"Execution Layer"}),"\n",(0,o.jsx)(a.p,{children:"Describes the domain layer of the delta ecosystem, as all transaction execution and compute occurs on domains."}),"\n",(0,o.jsx)(a.h3,{id:"validator",children:"Validator"}),"\n",(0,o.jsx)(a.p,{children:"A compute node on the network communicating with other validators (its peers) to keep track of the system and its state."}),"\n",(0,o.jsx)(a.h3,{id:"domain",children:"Domain"}),"\n",(0,o.jsx)(a.p,{children:"A local execution environment in delta. In addition to any custom code (including frontend interfaces and application logic), a domain contains an executor which handles the domain's integration with the delta base layer."}),"\n",(0,o.jsx)(a.h3,{id:"executor",children:"Executor"}),"\n",(0,o.jsx)(a.p,{children:"The component of a domain which contains a copy of the domain's shard (including all vaults and balances), handles the creation of SDLs, coordinates proof generation, and communicates with the delta base layer. Domain operators will use the delta SDK to set up and optionally customize their executor."}),"\n",(0,o.jsx)(a.h3,{id:"shard",children:"Shard"}),"\n",(0,o.jsx)(a.p,{children:"Global state on the base layer is organized into shards, where each domain owns a single shard. A shard contains vaults and balances for the accounts and programs operating on that domain, and domains may only debit from their owned shard (credits can be applied to external shards)."}),"\n",(0,o.jsx)(a.h3,{id:"transaction",children:"Transaction"}),"\n",(0,o.jsx)(a.p,{children:'A signed message to change state. Transactions which occur on domains may be referred to as "user-level transactions" or sometimes "intents." Transactions from domains to the base layer (submission of SDLs and proofs) are referred to as "execution transactions," and transactions directly to the base layer (deployment of a new domain or validator) are "base layer transactions."'}),"\n",(0,o.jsx)(a.h3,{id:"state-diff",children:"State Diff"}),"\n",(0,o.jsx)(a.p,{children:"A change to a specific vault on a specific shard, which is created by summarizing the user-level transactions which have occurred on the domain affecting that vault."}),"\n",(0,o.jsx)(a.h3,{id:"state-diff-list-sdl",children:"State Diff List (SDL)"}),"\n",(0,o.jsx)(a.p,{children:"An aggregated list of state diffs for a given domain's shard. SDLs are submitted to the base layer to update balances on the shard and finalize the user-level transactions."}),"\n",(0,o.jsx)(a.h3,{id:"sdl-proof",children:"SDL Proof"}),"\n",(0,o.jsx)(a.p,{children:"A RISC-V proof that a given SDL is valid, meaning all summarized user-level transactions followed the applicable laws."}),"\n",(0,o.jsx)(a.h3,{id:"laws",children:"Laws"}),"\n",(0,o.jsx)(a.p,{children:"Rules that user-level transactions must abide by in order to be valid. The laws are what's proven by the proof system."}),"\n",(0,o.jsx)(a.h3,{id:"global-laws",children:"Global Laws"}),"\n",(0,o.jsx)(a.p,{children:"The rules of the delta network which apply across all user-level transactions in all domains. These are designed to be minimal and only restrict behavior that would break the network (e.g., a debit transaction must have a valid signature from the vault owner, and a vault balance must be more than the debited amount)."}),"\n",(0,o.jsx)(a.h3,{id:"local-laws",children:"Local Laws"}),"\n",(0,o.jsx)(a.p,{children:"Rules that are imposed by a domain and apply to user-level transactions which occur on that domain."}),"\n",(0,o.jsx)(a.h3,{id:"planck",children:"Planck"}),"\n",(0,o.jsx)(a.p,{children:"The minimal denomination for fungible tokens on the delta network."}),"\n",(0,o.jsx)(a.h3,{id:"ela",children:"Executor Lease Agreement (ELA)"}),"\n",(0,o.jsx)(a.p,{children:"A record stored at the base layer which identifies a domain along with the domain's executor and owned shard."}),"\n",(0,o.jsx)(a.h3,{id:"vault",children:"Vault"}),"\n",(0,o.jsx)(a.p,{children:"A data structure which exists in execution state (on shards). There are two kinds of vaults: token mints and token holdings. Vaults are identified by the pubkey hash digest (of the owner) and the shard (of the domain where the vault is stored)."}),"\n",(0,o.jsx)(a.h3,{id:"token-mint",children:"Token Mint"}),"\n",(0,o.jsx)(a.p,{children:"A vault type which represents a non-native token on the delta network. Token mint vaults do not store tokens, only information. This includes the token ID (equivalent to the vault ID), minted token supply, and token metadata (token name and symbol/ticker). Upon creation of a new token mint, the initial supply and credited token holding vaults are defined."}),"\n",(0,o.jsx)(a.h3,{id:"token-holding",children:"Token Holding"}),"\n",(0,o.jsx)(a.p,{children:'A "typical" vault, which holds tokens and is owned by either a user, program, or domain executor.'}),"\n",(0,o.jsx)(a.h3,{id:"debit-debit-allowances",children:"Debit (debit allowances)"}),"\n",(0,o.jsx)(a.p,{children:"A signable user-level transaction message used to transfer tokens from a token holding vault. A debit allowance specifies a maximum allowed debit for a given token ID and token holding vault. Once signed by the private key of the vault, up to the signed amount can be debited (based on the executor logic)."})]})}function h(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>l});var t=n(6540);const o={},s=t.createContext(o);function i(e){const a=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);