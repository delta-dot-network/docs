"use strict";(self.webpackChunkdelta_docs_1=self.webpackChunkdelta_docs_1||[]).push([[236],{4309:(e,n,a)=>{a.d(n,{A:()=>o});const o=a.p+"assets/images/transaction_workflow-9832138643ee5209974135ed2d71f2f5.png"},4687:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"background/laws","title":"Laws and Proofs","description":"Global and Local laws, and how they affect consensus","source":"@site/docs/background/laws.md","sourceDirName":"background","slug":"/background/laws","permalink":"/docs/docs/background/laws","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Laws and Proofs","description":"Global and Local laws, and how they affect consensus","sidebar_label":"Laws and Proofs","sidebar_position":5},"sidebar":"docSidebar","previous":{"title":"Transactions","permalink":"/docs/docs/background/transactions"}}');var s=a(4848),i=a(8453);const t={title:"Laws and Proofs",description:"Global and Local laws, and how they affect consensus",sidebar_label:"Laws and Proofs",sidebar_position:5},r="Laws and Proving on the delta Network",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Proving Workflow",id:"proving-workflow",level:2},{value:"Proofs in the Transaction Workflow",id:"proof-workflow",level:3},{value:"Defining Local Laws",id:"defining-local-laws",level:3},{value:"Proof Aggregation",id:"proof-aggregation",level:3},{value:"Guide: Writing a Local Law",id:"guide-writing-a-local-law",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"laws-and-proving-on-the-delta-network",children:"Laws and Proving on the delta Network"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Coming soon: Declaring and enforcing ",(0,s.jsx)(n.strong,{children:"Token Laws"})]})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:'"Laws" on delta describe the rules and logic limiting user transactions. There are three categories of laws on delta:'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Global Laws"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Applied to every transaction on every domain"}),"\n",(0,s.jsx)(n.li,{children:"Intentionally minimal, only restricting activity that would break the network (e.g. valid signature required, balances cannot be negative)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Local (Domain) Laws"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Optionally defined by a domain, and only applied to transactions occurring on that domain"}),"\n",(0,s.jsx)(n.li,{children:"Highly flexible, can be used to restrict activity (e.g. valid KYC credentials required to transact) or prove fair program execution (e.g. token distribution followed set logic)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Token Laws"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Optionally defined by the token issuer, and applied to all transactions involving the token on every domain"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"proving-workflow",children:"Proving Workflow"}),"\n",(0,s.jsx)(n.h3,{id:"proof-workflow",children:"Proofs in the Transaction Workflow"}),"\n",(0,s.jsxs)(n.p,{children:["The enforcement and proving of Laws is part of the transaction lifecycle:",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.strong,{children:"Transaction"}),(0,s.jsx)("br",{}),"\nUsers sign transaction messages."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Execution"}),(0,s.jsx)("br",{}),"\nValid transactions are immediately applied to the domain's local balances and added to the pending State Diff List (SDL). Global Laws are enforced at this stage to ensure only valid transactions proceed. It is best practice to also include any Local Laws in domain execution logic."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Settlement"}),(0,s.jsx)("br",{}),"\nWhen a domain chooses to settle changes to the base layer, the State Diff List, transaction context, vault balances, and Law programs are processed through a RISC-V zkVM to generate a zero-knowledge proof. This proof and the associated State Diff List are sent to the Base Layer for validation and final application."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"transaction_workflow.png",src:a(4309).A+"",width:"2868",height:"754"})}),"\n",(0,s.jsx)(n.h3,{id:"defining-local-laws",children:"Defining Local Laws"}),"\n",(0,s.jsxs)(n.p,{children:["Local Laws are optional, and defined by the domain. A domain can declare their local laws by providing the Risc-V Proof Program Hash when declaring their ",(0,s.jsx)(n.a,{href:"/docs/docs/background/glossary#ela",children:"Executor Lease Agreement"})," during domain setup."]}),"\n",(0,s.jsx)(n.h3,{id:"proof-aggregation",children:"Proof Aggregation"}),"\n",(0,s.jsxs)(n.p,{children:["delta's proof program uses proof aggregation to maintain efficiency regardless of local law complexity. Local laws (if defined) are proven first. The resulting zk-proof is then validated as part of the global law proof program. As a result, any number or complexity of local laws compress to just a few bytes while remaining cryptographically secure. ",(0,s.jsx)("br",{}),"\nThe resulting overall workflow is seen below:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"transaction_proving_workflow.png",src:a(8847).A+"",width:"2774",height:"1248"})}),"\n",(0,s.jsx)(n.h2,{id:"guide-writing-a-local-law",children:"Guide: Writing a Local Law"}),"\n",(0,s.jsx)(n.p,{children:"Local laws must be expressed as a program in order to be proven in a Risc-V zkVM. For example, if a domain wants to restrict activity to only users on a specific allowlist, this will be enforced by writing a program which asserts that each transaction message sender (and, optionally, transfer recipient) matches an address on the allowlist."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="Example code (for illustative purposes only): Enforce AllowList"',children:'sp1_zkvm::entrypoint!(main);\nuse std::collections::HashSet;\npub fn main() {\n    // Read inputs from the zkVM\n    let sdl = sp1_zkvm::io::read::<Vec<u8>>();\n    let _verifiables = sp1_zkvm::io::read::<[u8; 4]>();\n    let verification_context = sp1_zkvm::io::read::<Vec<u8>>();\n\n    // Parse allowlist and transactions from inputs\n    let allowlist = parse_allowlist(&verification_context);\n    let transactions = parse_transactions(&sdl);\n    \n    // Validate all signers are on the allowlist\n    for transaction in &transactions {\n        let signer_address = extract_signer_address(transaction);\n        \n        assert!(\n            allowlist.contains(&signer_address),\n            "Signer not on allowlist"\n        );\n    }\n\n    // All transactions passed - commit the SDL\n    sp1_zkvm::io::commit_slice(&sdl);\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Our team can help translate your required local laws into provable programs. Please ",(0,s.jsx)(n.a,{href:"/docs/docs/building/request-sdk-access",children:"contact us"})," for more details."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>r});var o=a(6540);const s={},i=o.createContext(s);function t(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),o.createElement(i.Provider,{value:n},e.children)}},8847:(e,n,a)=>{a.d(n,{A:()=>o});const o=a.p+"assets/images/transaction_proving_workflow-d8873712ca5b8a6687a5b343158c51ad.png"}}]);